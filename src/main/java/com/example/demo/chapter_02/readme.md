# Java并发机制的底层实现原理

## 2.1 volatile的应用

1. volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。
2. 可见性意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。
3. volatile使用恰当的话，比synchronized执行成本要低，因为它不会引起线程上下文的切换和调度。
4. Java线程内存模型确保所有线程看到这个变量的值是一致的，Java语言规范第三版有如下定义：
>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获取这个变量

5. 在多处理器下，为了保证各处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存置为无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里；
6. Lock前缀指令会引起处理器缓存回写到内存；
7. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效；

## 2.2 synchronized的实现原理与应用

1. Java Se1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”；
2. Java Se1.6中锁以供有4种状态，级别由低到高为：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以升级但不能降级；

| 锁      | 优点 | 缺点 | 适用场景 |
| -       | :-:     | :-:    | - |
| 偏向锁   | 加锁和解锁无需额外消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景 | 
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快 | 
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行速度较长 |

## 2.3 原子操作的实现原理

1. 原子atomic本意是“不能被进一步分割的最小粒子”；
2. 原子操作意为“不可被中断的一个或一系列操作”;
3. 处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性；
4. 所谓总线锁就是使用处理器提供的一个LOCK # 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存，开销较大，实际情景如进行i++操作；
5. 所谓缓存锁定是指内存区域如果被还存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线声言LOCK # 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效；
6. 两种情况下处理器不会使用缓存锁定：

  * 数据不能被缓存在处理器内部，或数据跨多个缓存行，此时采用总线锁定；
  * 有些处理器不支持缓存锁定；

7. 使用循环CAS实现原子操作
>代码:Counter.java

8. CAS三大问题：ABA问题（加版本号解决），循环时间长开销大，以及只能保证一个共享变量的原子操作；