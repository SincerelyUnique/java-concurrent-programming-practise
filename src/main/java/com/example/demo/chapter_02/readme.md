# Java并发机制的底层实现原理

## 2.1 volatile的应用

1. volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。
2. 可见性意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。
3. volatile使用恰当的话，比synchronized执行成本要低，因为它不会引起线程上下文的切换和调度。
4. Java线程内存模型确保所有线程看到这个变量的值是一致的，Java语言规范第三版有如下定义：
>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获取这个变量

5. 在多处理器下，为了保证各处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存置为无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里；
6. Lock前缀指令会引起处理器缓存回写到内存；
7. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效；

## 2.2 synchronized的实现原理与应用

1. Java Se1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”；
2. Java Se1.6中锁以供有4种状态，级别由低到高为：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以升级但不能降级；

| 锁      | 优点 | 缺点 | 适用场景 |
| -       | :-:     | :-:    | - |
| 偏向锁   | 加锁和解锁无需额外消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景 | 
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快 | 
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行速度较长 |

## 2.3 原子操作的实现原理

1. 原子atomic本意是“不能被进一步分割的最小粒子”；
2. 原子操作意为“不可被中断的一个或一系列操作”